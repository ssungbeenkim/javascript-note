// 비트연산자.
// https://velog.io/@ansunny1170/JavaScript-Tutorial.48

// 1. 비트연산자 AND(&)
// 두 비트가 모두 1일 때만 1을 반환한다.

console.log((1).toString(2)); // 1
console.log((2).toString(2)); // 10
console.log((3).toString(2)); // 11
console.log(0b0101 & 0b0110); // 4가 출력된다. 0100이 되기 때문이다.
console.log((1 & 3).toString(2)); // 1
console.log((2 & 3).toString(2)); // 10

// 2. 비트연산자 OR(|)
// 두 비트 중 하나라도 1이면 1을 반환한다.

console.log(0b0101 | 0b0110); // 7이 출력된다. 0111이 되기 때문이다.
console.log((1 | 3).toString(2)); // 11
console.log((2 | 3).toString(2)); // 11

// 3. 비트연산자 XOR(^)
// 두 비트가 서로 다르면 1을 반환한다.

console.log(0b0101 ^ 0b0110); // 3이 출력된다. 0011이 되기 때문이다.
console.log((1 ^ 3).toString(2)); // 10
console.log((2 ^ 3).toString(2)); // 1

// 4. 비트연산자 NOT(~)
// 비트를 반전시킨다. 0은 1로, 1은 0으로 바꾼다.

/* * https://velog.io/@ansunny1170/JavaScript-Tutorial.48 참고
JavaScript는 숫자를 64비트 부동 소수점 숫자로 저장하지만 
비트 연산이 수행되기 전에 JavaScript는 숫자를 32비트 부호 있는 정수로 변환한다.
비트 연산이 수행된 후 결과는 64비트 JavaScript 숫자로 다시 변환된다.

모든 비트 연산은 32비트 이진수에서 수행된다.
JavaScript 이진수는 2의 보수 형식으로 저장된다.
부호 있는 정수는 가장 왼쪽 비트를 음수(빼기) 기호로 사용
0000 0000 0000 0000 0000 0000 0000 0101 을 비트연산 NOT(~)을 하면
1111 1111 1111 1111 1111 1111 1111 1010 이 된다. 이것을 2의 보수 표현으로 보면 
1111 1111 1111 1111 1111 1111 1111 1001 + 1 이고 
원래의 수를 찾으려고 하면 1001을 반전, 0110 이 되므로 6이다. 
그러므로 ~(0101)은 -6이 되는 것이다. 


*/
console.log(0b0101); // 5
console.log(~0b0101); // -6이 출력된다.
//?
console.log(0b1010); // 10

console.log((~1).toString(2));
console.log((~2).toString(2));

console.log(0b0001); // 1
console.log(~0b0001); // -2가 출력된다.

// 5. 비트연산자 Left Shift(<<)
// 왼쪽으로 비트를 이동시킨다. 빈자리는 0으로 채운다.

console.log(0b0101 << 1); // 10이 출력된다. 1010이 되기 때문이다.
console.log((1 << 1).toString(2)); // 10
console.log((2 << 1).toString(2)); // 100

// 6. 비트연산자 Right Shift(>>)
// 오른쪽으로 비트를 이동시킨다. 빈자리는 부호비트로 채운다.
// 즉 부호는 유지하면서 지정한 수만큼 오른쪽으로 이동시키는것.
// 맨 왼쪽 비트값을 그대로 왼쪽에 붙여주는 것.  (부호비트는 0이면 0, 1이면 1)

console.log(0b0101 >> 1); // 2가 출력된다. 0010이 되기 때문이다. (넘어간 비트는 버림)
console.log((-5 >> 1).toString(2)); // -3
// 1111 1111 1111 1111 1111 1111 1111 1011 (-1)
// 1111 1111 1111 1111 1111 1111 1111 1101 (-3)

// 7. 비트연산자 Zero-fill Right Shift(>>>)
// 오른쪽으로 비트를 이동시킨다. 빈자리는 0으로 채운다.
// 즉 맨 왼쪽에 0을 추가하고 맨 오른쪽 값을 삭제한다.

console.log(0b0101 >>> 1); // 2가 출력된다. 0010이 되기 때문이다. (넘어간 비트는 버림)
console.log((1 >>> 1).toString(2)); // 0
