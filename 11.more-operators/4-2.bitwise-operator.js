/* 
JavaScript의 수는 따로 숫자형이 있지 않으며 IEEE754로 규정된 64비트 부동 소수점이다.
비트 연산이 수행되기 전에 JavaScript는 숫자를 32비트 부호 있는 정수로 변환한다.
비트 연산이 수행된 후 결과는 64비트 JavaScript 숫자로 다시 변환된다. */
//IEEE754: https://ko.wikipedia.org/wiki/IEEE_754

// 비트연산자.
// https://velog.io/@ansunny1170/JavaScript-Tutorial.48

// 1. 비트연산자 AND(&)
// 두 비트가 모두 1일 때만 1을 반환한다.

console.log((1).toString(2)); // 1
console.log((2).toString(2)); // 10
console.log((3).toString(2)); // 11
console.log(0b0101 & 0b0110); // 4가 출력된다. 0100이 되기 때문이다.
console.log((1 & 3).toString(2)); // 1
console.log((2 & 3).toString(2)); // 10

console.log('-----------------2');
// 2. 비트연산자 OR(|)
// 두 비트 중 하나라도 1이면 1을 반환한다.

console.log(0b0101 | 0b0110); // 7이 출력된다. 0111이 되기 때문이다.
console.log((1 | 3).toString(2)); // 11
console.log((2 | 3).toString(2)); // 11
console.log('-----------------3');
// 3. 비트연산자 XOR(^)
// 두 비트가 서로 다르면 1을 반환한다.

console.log(0b0101 ^ 0b0110); // 3이 출력된다. 0011이 되기 때문이다.
console.log((1 ^ 3).toString(2)); // 10
console.log((2 ^ 3).toString(2)); // 1

console.log('-----------------4');
// 4. * 비트연산자 NOT(~)
// 비트를 반전시킨다. 0은 1로, 1은 0으로 바꾼다.

/* * https://velog.io/@ansunny1170/JavaScript-Tutorial.48 참고

JavaScript의 64비트 부동 소수점이지만 모든 비트 연산은 32비트 이진수에서 수행된다.
JavaScript 이진수는 2의 보수 형식으로 저장된다.
부호 있는 정수는 가장 왼쪽 비트를 음수(빼기) 기호로 사용
0000 0000 0000 0000 0000 0000 0000 0101 을 비트연산 NOT(~)을 하면
1111 1111 1111 1111 1111 1111 1111 1010 이 된다. 이것을 2의 보수 표현식으로 거꾸로 가보면
1111 1111 1111 1111 1111 1111 1111 1001 + 1 이고 
원래의 수를 찾으려고 하면 1001을 반전, 
0000 0000 0000 0000 0000 0000 0000 0110 이 되므로 6이다. 
그러므로 ~(0101)은 -6이 되는 것이다.*/

console.log(0b0101); // 5
console.log(~0b0101); // -6이 출력된다.
//?
console.log(0b1010); // 10

console.log(0b0001); // 1
console.log(~0b0001); // -2가 출력된다.

console.log(~1); // -2
//0...0001
//1...1110 - 1 => 1...1101 => 0...0010 => 2
console.log((~1).toString(2)); // -10
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
console.log(~0);
//0...0000
/* 
가장 큰 값을 만들어보자. 
1...1110에서 >>>1 연산 해주면 되지 않을까?
*/
console.log((~1 >>> 1).toString(2)); // 1111111111111111111111111111111
console.log((~1 >>> 1).toString(2).length); //31
// 표현하자면 0b0111 1111 1111 1111 1111 1111 1111 1111 이 되는 것이다!
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
console.log(Number.MAX_SAFE_INTEGER.toString(2)); // 11111111111111111111111111111111111111111111111111111
console.log(Number.MAX_SAFE_INTEGER.toString(2).length); // 53자리 2진수다.
/* 비트 연산을 할 때는 32비트로 변환해서 연산을 하기 때문에 위의 31자리 수가 나오는 것이고
53자리 수가 나오는 것은 64비트로 변환해서 연산을 하기 때문이다.
부동소수점 연산에서 1/11/53 으로 부호, 지수, 가수를 나누어 저장하기 때문에 
가수부의 최대 길이는 53비트. 
즉 +11111111111111111111111111111111111111111111111111111 이 수를 64비트 부동소수점으로 저장할 때는 
1.1111111111111111111111111111111111111111111111111111 * 2^52 이며
양수이므로 부호에 0을 저장하고 
지수부에 52를 저장하고  
가수부에 2*52를 저장했을 것. 
 */

console.log('-----------------5');
// 5. 비트연산자 Left Shift(<<)
// 왼쪽으로 비트를 이동시킨다. 빈자리는 0으로 채운다.

console.log(0b0101 << 1); // 10이 출력된다. 1010이 되기 때문이다.
console.log((1 << 1).toString(2)); // 10
console.log((2 << 1).toString(2)); // 100

console.log('-----------------6');
// 6. 비트연산자 Right Shift(>>)
// 오른쪽으로 비트를 이동시킨다. 빈자리는 부호비트로 채운다.
// 즉 부호는 유지하면서 지정한 수만큼 오른쪽으로 이동시키는것.
// 맨 왼쪽 비트값을 그대로 왼쪽에 붙여주는 것.  (부호비트는 0이면 0, 1이면 1)
console.log(0b0101); // 5
console.log(0b0101 >> 1); // 2가 출력된다. 0010이 되기 때문이다. (넘어간 비트는 버림)
console.log((5 >> 1).toString(2)); // 2진수로 10, 10진수로 2
// 0000 0000 0000 0000 0000 0000 0000 0011 (3)
// 0000 0000 0000 0000 0000 0000 0000 0001 (1)
console.log(-1 >> 1); // -1이 출력된다.
// ... 0000 0001 1
// ... 1111 1110
// ... 1111 1111 -1

console.log('-----------------7');
// 7. 비트연산자 Zero-fill Right Shift(>>>)
// 오른쪽으로 비트를 이동시킨다. 빈자리는 0으로 채운다.
// 즉 맨 왼쪽에 0을 추가하고 맨 오른쪽 값을 삭제한다.

console.log(0b0101 >>> 1); // 2가 출력된다. 0010이 되기 때문이다. (넘어간 비트는 버림)
console.log((1 >>> 1).toString(2)); // 0
console.log(-1 >>> 1); // 2147483647이 출력된다. (0b0111 1111 1111 1111 1111 1111 1111 1111)
// 맨 왼쪽 0이 추가되기 때문에 부호비트가 0이 되고, 나머지 비트는 그대로 유지된다. 그러므로 큰 양수가 된다.

// 잘 정리된 블로그: https://80000coding.oopy.io/5226d086-ed18-482c-a58b-fe65f040a82e
